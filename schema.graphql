type RegistryFactory @entity {
  id: ID!
  address: Bytes!
  registryCount: Int!
  registries: [Registry!]
}

type Registry @entity {
  id: ID!
  address: Bytes!
  node: Bytes!                        # Registry ENS node
  repoCount: Int!
  repos: [Repo!]
  factory: RegistryFactory! @derivedFrom(field: "registries")
}

type Repo @entity {
  id: ID!                             # Repo ENS address
  address: Bytes!                     # Repo address
  name: String!                       # Repo name
  node: Bytes!                        # Repo ENS node
  lastVersion: Version                # Last Version
  versions: [Version!] @derivedFrom(field: "repo")
  registry: Registry! @derivedFrom(field: "repos")
}

type Version @entity {
  id: ID!                             # ID concat versionId and semanticVersion
  semanticVersion: String!            # Semantic version
  contractAddress: Bytes!             # Smart contract address
  content: String!                    # Content URI
  repo: Repo!                         # Repo entity
  apps: [App!] @derivedFrom(field: "repoVersion")
}

type OrgFactory @entity {
  id: ID!
  address: Bytes!
  orgCount: Int!
  organizations: [Organization!]
}

type Organization @entity {
  id: ID!                             # Kernel proxy address
  address: Bytes!                     # Kernel address
  acl: Bytes                          # Acl address
  recoveryVault: Bytes!               # Address of the recovery Vault instance
  apps: [App!]                        # List of apps
  permissions: [Permission!]          # Permission object
  factory: OrgFactory! @derivedFrom(field: "organizations")
}

type App @entity {
  id: ID!                             # App proxy address
  address: Bytes!                     # App address
  appId: String!                      # ENS namehash of the aragonPM repo
  isForwarder: Boolean!               # Whether the app is Forwarder
  isUpgradeable: Boolean!             # Whether the app is upgradeable
  implementation: Bytes               # Address of the app instance or base
  repoVersion: Version                # Repo Version entity
  artifact: String                    # Artifact.json metadata
  organization: Organization! @derivedFrom(field: "apps")
  roles: [Role!] @derivedFrom(field: "app")
}

type Role @entity {
  id: ID!                             # ID concat of app and role hash
  app: App!                           # App entity
  hash: Bytes!                        # Role name hash
  manager: Bytes!                     # Manager address
  allowedEntities: [Permission!] @derivedFrom(field: "role")
}

type Permission @entity {
  id: ID!                             # ID concat of app, role and entity
  app: App                            # App entity
  role: Role!                         # Role entity
  entity: Bytes!                      # Address assigned the permissions
  paramsHash: Bytes                   # Params hash
}
